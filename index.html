<!DOCTYPE html>
<meta charset="utf-8">


<style>

.pathSusceptible {
  fill: none;
  stroke: green;
}

.pathDeath {
  fill: none;
  stroke: red;
}

.pathInfection {
  fill: none;
  stroke: blue;
}

</style>

<canvas style="position: absolute; left: 0; top: 0"></canvas>
<svg id="infectionGraph" style="position: absolute; left: 550; top: 0"></svg>
<svg id="deathGraph" style="position: absolute; left: 550; top: 300"></svg>

<script src="js/d3.v4.min.js"></script>
<script src="js/lodash.js"></script>
<script>



const margin = {top: 50, right: 10, bottom: 50, left: 50},
      width = 400 - margin.left - margin.right,
      height = 250 - margin.top - margin.bottom

const svgInfection = d3.select("#infectionGraph")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", `translate(${margin.left}, ${margin.top})`)
    .attr("width", width)
    .attr("height", height)
  
const pathInfection = svgInfection
  .append('path')
    .attr("class", "pathInfection")

const svgDeath = d3.select("#deathGraph")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", `translate(${margin.left}, ${margin.top})`)
    .attr("width", width)
    .attr("height", height)
  
const pathDeath = svgDeath
  .append('path')
    .attr("class", "pathDeath")

const pathSusceptible = svgDeath
  .append('path')
    .attr("class", "pathSusceptible")



const line = d3.line()
  .curve(d3.curveCatmullRom.alpha(0.5))

const yScaleInfection = d3.scaleLinear()
  .range([+svgInfection.attr("height"), 0])

const yScaleDeath = d3.scaleLinear()
  .range([+svgDeath.attr("height"), 0])


d3.json("data/FR-dataGrid2011.json", data => {

  //extract lat/lon and their sign (positive/negative) from Grid cell ID
  const reLat = /.*[NS]([0-9]+)[EW].*/,
    reLon = /.*[EW]([0-9]+)/,
    reLatSign = /.*([NS]).*/
    reLonSign = /.*([EW]).*/

  data.forEach(d => {
    const lat = reLat.exec(d.GRD_ID)[1]/100 || null;
    const lon = reLon.exec(d.GRD_ID)[1]/100 || null;
    const latSign = reLatSign.exec(d.GRD_ID)[1] === "N" ? 1 : -1;
    const lonSign = reLonSign.exec(d.GRD_ID)[1] === "E" ? 1 : -1;

    d.lat = lat * latSign;
    d.lon = lon * lonSign;

  })

  //initial image
  let [imageData, imWidth, imHeight, dataGrid] = convertDatatoImage(data);
  loadImage(imageData, imWidth, imHeight);

  //SIR Model parameters
  const beta = 0.01 //how transmittable the disease is. One bite is all it takes!
  const gamma = 2 //2 incrementation how fast you go from zombie to dead. Has to be some sort of average of how fast our zombie hunters is working...

  //Let's put patient 0 near
  const posI_0 = 410204
  dataGrid[posI_0] = 1

  //Initial state
  let nInfected = [],
      nRemoved = [],
      nSusceptible = [],
      ct = 0;

  let [pInfected, pRemoved, pSusceptible] = storeState(dataGrid, imWidth, imHeight)

  nInfected.push(pInfected)
  nRemoved.push(pRemoved)
  nSusceptible.push(pSusceptible)

  let iter = 0;

  //Run simulation
  let timer = d3.timer(function() {
    
    //simulation increment
    dataGrid = euler(dataGrid, beta, gamma, imWidth, imHeight);

    //generate new image from new data
    let dataImage = convertMatrixtoImage(dataGrid, imWidth, imHeight);
    updateImageData(dataImage, imWidth, imHeight)

    //store iteration results
    let [pInfected, pRemoved, pSusceptible] = storeState(dataGrid, imWidth, imHeight)

    if (ct++ > width) {
      nInfected.shift();
      nRemoved.shift();
      nSusceptible.shift();
    }
    nInfected.push(pInfected)
    nRemoved.push(pRemoved)
    nSusceptible.push(pSusceptible)

    yScaleInfection
      .domain([0, d3.max(nInfected)]);
    yScaleDeath
      .domain([0, d3.max(d3.merge([nRemoved, nSusceptible]))])

    
    pathInfection
      .attr('d', line(nInfected.map((d,i) => {
        return [i, yScaleInfection(d)];
      })));

    pathDeath
      .attr('d', line(nRemoved.map((d,i) => {
        return [i, yScaleDeath(d)];
      })));

    pathSusceptible
      .attr('d', line(nSusceptible.map((d,i) => {
        return [i, yScaleDeath(d)];
      })));


  iter += 1
  if (iter >= 400) timer.stop()

});



})//d3.json

function storeState(dataGrid, imWidth, imHeight){

  let pI = 0,
      pR = 0,
      pS = 0

  for (let y = 0; y < imHeight; y++) {
    for (let x = 0; x < imWidth; x++) {
      let pos = (y * imWidth + x) * 4 + 0; // position in buffer based
        pI += dataGrid[pos]
        pR += dataGrid[pos+1]
        pS += dataGrid[pos+2]
    }
  }
  return [pI, pR, pS]
}

function convertDatatoImage(data){
  const [matrixData, extentLon, extentLat, maxValue] = formatData(data);
  const imWidth = matrixData[0].length
  const imHeight = matrixData.length

  let buffer = new Uint8ClampedArray(imWidth * imHeight * 4); // have enough bytes

  //start by y since data grouped by latitude first
  for (let y = 0; y < imHeight; y++) {
    for (let x = 0; x < imWidth; x++) {
        const pos = (y * imWidth + x) * 4; // position in buffer based on x and y
        buffer[pos  ] = 0; // some R value [0, 255]
        buffer[pos+1] = 0;           // some G value
        buffer[pos+2] = matrixData[y][x];           // some B value
        // buffer[pos+2] = Math.round(255*matrixData[y][x]["population"]/maxValue); // some B value
        buffer[pos+3] = 255;           // set alpha channel
    }
  }

  // create off-screen canvas element
  // let canvas = document.createElement('canvas'),
  //     ctx = canvas.getContext('2d');
  const canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d');

  canvas.width = imWidth;
  canvas.height = imHeight;


  // create imageData object
  let imData = ctx.createImageData(imWidth, imHeight);

  // set our buffer as source
  imData.data.set(buffer);

  // update canvas with new data
  ctx.putImageData(imData, 0, 0);

  const dataUri = canvas.toDataURL(); // produces a PNG file

  return [dataUri, imWidth, imHeight, buffer]
}


function convertMatrixtoImage(dataBuffer, imWidth, imHeight){

  let buffer = new Uint8ClampedArray(imWidth * imHeight * 4); // have enough bytes

  //normalize data
  for (let y = 0; y < imHeight; y++) {
    for (let x = 0; x < imWidth; x++) {
        var pos = (y * imWidth + x) * 4; // position in channel
        buffer[pos  ] = dataBuffer[pos  ];           // some R value [0, 255]
        buffer[pos+1] = dataBuffer[pos+1];           // some G value
        buffer[pos+2] = dataBuffer[pos+2];           // some B value
        buffer[pos+3] = 255;           // set alpha channel
    }
  }
  // create off-screen canvas element
  // let canvas = document.createElement('canvas'),
  //     ctx = canvas.getContext('2d');
  const canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d');

  canvas.width = imWidth;
  canvas.height = imHeight;

  // create imageData object
  let imData = ctx.createImageData(imWidth, imHeight);

  // set our buffer as source
  imData.data.set(buffer);

  // update canvas with new data
  ctx.putImageData(imData, 0, 0);

  const dataUri = canvas.toDataURL(); // produces a PNG file

  return dataUri
}


function loadImage(dataImage, imWidth, imHeight){

  const img = new Image()
  const canvas = d3.select('canvas')
      .attr("width", imWidth)
      .attr("height", imHeight)

  const ctx = canvas.node().getContext('2d')

  img.src = dataImage

  img.onload = function() {

    //flip image vertically
    ctx.scale(1,-1);
    ctx.translate(0,-imHeight);

    ctx.drawImage(img, 0, 0, imWidth, imHeight)
  }
}



function updateImageData(dataImage, imWidth, imHeight){

  const img = new Image()
  const canvas = d3.select('canvas')
  const ctx = canvas.node().getContext('2d')
  img.src = dataImage

  img.onload = function() {

    ctx.drawImage(img, 0, 0, imWidth, imHeight)
  }
}


function formatData(data){

  //binning data by 0.02 lat and lon units
  //keep lon and lat not decimal to fix sorting problem
  const nestedData = d3.nest()
    .key(d => _.floor(d.lat*500, -1)/5)
    .sortKeys((a, b) => {
      a = parseFloat(a);
      b=parseFloat(b);
      return d3.ascending(a, b)
    })
    .key(d => _.floor(d.lon*500, -1)/5)
    .sortKeys((a, b) => {
      a = parseFloat(a);
      b=parseFloat(b);
      return d3.ascending(a, b)
    })
    .entries(data)

  //organize data in grid with access by lat/lon keys
  let gridData = {};
  nestedData.map(lat => lat.values.map(
    lon => {
      if (!gridData[lat.key]) gridData[lat.key] = {}
      gridData[lat.key][lon.key] = d3.sum(lon.values, d => d.TOT_P)
      }
    )
  )

  const extentLon = d3.extent(data, d => d.lon*100);
  const extentLat = d3.extent(data, d => d.lat*100);

  const latRange = d3.range(extentLat[0], extentLat[1]+2, 2)
  const lonRange = d3.range(extentLon[0], extentLon[1]+2, 2)

  //put data into matrix covering entire space
  let matrixLatLon = new Array(latRange.length);
  for(var i=0; i<latRange.length; i++) {
    matrixLatLon[i] = new Array(lonRange.length);
  }

  latRange.map((lat, i) => lonRange.map(
    (lon, j) => {
      if (gridData[lat] == null) matrixLatLon[i][j] = 0
      else matrixLatLon[i][j] = gridData[lat][lon] | 0
      }
    )
  )

  const allValues = _.flatten(matrixLatLon)
  const maxValue = d3.max(allValues)

  // return [matrixData, extentLon, extentLat, maxValue]
  return [matrixLatLon, extentLon, extentLat, maxValue]

}//formatData



function euler(imData, beta, gamma, imWidth, imHeight){

  let newData = []
  //start by y since data grouped by latitude first
  for (let y = 0; y < imHeight; y++) {
    for (let x = 0; x < imWidth; x++) {
      const posS = (y * imWidth + x) * 4 + 2; //blue layer
      const posI = (y * imWidth + x) * 4 + 0;
      const posR = (y * imWidth + x) * 4 + 1; // position in buffer based on x and y

      const posAlpha = (y * imWidth + x) * 4 + 3; // position in buffer based on x and y
      newData[posAlpha] = 255 //alpha channel

      const posS_a = ((y-1) * imWidth + x) * 4 + 2;
      const posI_a = ((y-1) * imWidth + x) * 4 + 0;

      const posS_b = ((y+1) * imWidth + x) * 4 + 2;
      const posI_b = ((y+1) * imWidth + x) * 4 + 0;

      
      //new infection
      let newInfection = (beta * (

        //line above
        imData[posS_a  ] * imData[posI_a  ] +
        imData[posS_a-4] * imData[posI_a-4] +
        imData[posS_a+4] * imData[posI_a+4] +

        //same line
        imData[posS  ] * imData[posI  ] +
        imData[posS-4] * imData[posI-4] +
        imData[posS+4] * imData[posI+4] +

        //line below
        imData[posS_b  ] * imData[posI_b  ] +
        imData[posS_b-4] * imData[posI_b-4] +
        imData[posS_b+4] * imData[posI_b+4]

         )

      ) | 0

      //infected people dying
      let newDead = gamma * imData[posI] | 0


      //if infection is not greater than people in cell
      if (newInfection <= imData[posS]){
        newData[posS] = imData[posS] - newInfection

        //if not all the infected people are dead
        if (imData[posI] + newInfection >= newDead) {
          newData[posI] = imData[posI] + newInfection - newDead
          newData[posR] = imData[posR] + newDead
        }
        else {
          newData[posI] = 0
          newData[posR] = imData[posR] + imData[posI]
        }
        
      } 
      //if more infection than susceptible
      else {

        //if possible new death is possible
        if (imData[posI] + imData[posS] >= newDead) {
          newData[posS] = 0 //no susceptible left
          newData[posI] = imData[posI] + imData[posS] - newDead
          newData[posR] = imData[posR] + newDead
        }
        else {
          newData[posS] = 0
          newData[posI] = 0
          newData[posR] = imData[posR] + imData[posS] + imData[posI]
        }
      }
      
    }
  }
  return newData
}

function kernel(d1, imWidth, imHeight, k) {
  let d2 = []

  for (let y = 0; y < imHeight; y++) {
    for (let x = 0; x < imWidth; x++) {
      const pos = (y * imWidth + x) * 4 + 2; //blue layer
      const pos_a = ((y-1) * imWidth + x) * 4 + 2;
      const pos_b = ((y+1) * imWidth + x) * 4 + 2;
      // WARNING: Optimized code.
      d2[pos] = (
          d1[pos_a - 4] * k[0]
        + d1[pos_a] * k[1]
        + d1[pos_a + 4] * k[2]
        + d1[pos-4] * k[3]
        + d1[pos] * k[4]
        + d1[pos + 4] * k[5]
        + d1[pos_b-4] * k[6]
        + d1[pos_b] * k[7]
        + d1[pos_b+4] * k[8]
      ) | 0
    }
  }

d1 = d2

}



</script>
